package cc.vergence.modules.exploit;

import cc.vergence.Vergence;
import cc.vergence.features.event.events.HurtEvent;
import cc.vergence.features.event.events.PacketEvent;
import cc.vergence.features.options.Option;
import cc.vergence.features.options.impl.*;
import cc.vergence.modules.Module;
import cc.vergence.modules.visual.JumpCircle;
import cc.vergence.util.color.ColorUtil;
import cc.vergence.util.other.FastTimerUtil;
import cc.vergence.util.other.TextureStorage;
import cc.vergence.util.player.PlayerEntityCopy;
import cc.vergence.util.render.utils.Render2DUtil;
import com.mojang.blaze3d.platform.GlStateManager;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.gl.ShaderProgramKeys;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.render.BufferBuilder;
import net.minecraft.client.render.Tessellator;
import net.minecraft.client.render.VertexFormat;
import net.minecraft.client.render.VertexFormats;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.*;
import net.minecraft.network.packet.s2c.play.EntityVelocityUpdateS2CPacket;
import net.minecraft.util.math.RotationAxis;
import net.minecraft.util.math.Vec3d;
import org.joml.Matrix4f;

import java.awt.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class Blink extends Module {
    public static Blink INSTANCE;
    private PlayerEntityCopy blinkPlayer;
    public static Vec3d lastPos = Vec3d.ZERO;
    private Circle blinkCircle = null;
    private final Queue<Packet<?>> storedPackets = new LinkedList<>();
    private final AtomicBoolean sending = new AtomicBoolean(false);
    private long lastAutoBlinkTime = System.currentTimeMillis();

    public Blink() {
        super("Blink", Category.EXPLOIT);
        INSTANCE = this;
    }

    public Option<EnumSet<Modes>> mode = addOption(new MultipleOption<Modes>("Mode", EnumSet.of(Modes.Circle)));
    public Option<Boolean> auto = addOption(new BooleanOption("Auto", false));
    public Option<Double> time = addOption(new DoubleOption("Time", 0.1, 10, 2, v -> auto.getValue()).setUnit("s"));
    public Option<Double> maxPackets = addOption(new DoubleOption("MaxPackets", 1, 2000, 20));
    public Option<Boolean> hurt = addOption(new BooleanOption("Hurt", false));
    public Option<Double> size = addOption(new DoubleOption("Size", 0.2, 2, 0.8, v -> mode.getValue().contains(Modes.Circle)));
    public Option<Color> color = addOption(new ColorOption("Color", new Color(251, 136, 255), v -> mode.getValue().contains(Modes.Circle)));

    @Override
    public String getDetails() {
        return String.valueOf(storedPackets.size());
    }

    @Override
    public void onEnable() {
        if (isNull() || mc.isIntegratedServerRunning() || mc.getNetworkHandler() == null) {
            disable();
            return;
        }

        lastPos = mc.player.getPos();
        mc.world.spawnEntity(new ClientPlayerEntity(mc, mc.world, mc.getNetworkHandler(), mc.player.getStatHandler(), mc.player.getRecipeBook(), mc.player.isSprinting(), mc.player.isSneaking()));
        sending.set(false);
        storedPackets.clear();
        lastAutoBlinkTime = System.currentTimeMillis();

        sendPackets();
    }

    @Override
    public void onDisable() {
        if (isNull()) {
            return;
        }

        sendPackets();

        if (blinkPlayer != null) {
            blinkPlayer.remove();
        }
        blinkPlayer = null;
        blinkCircle = null;
    }

    @Override
    public void onSendPacket(PacketEvent.Send event, Packet<?> packet) {
        if (isNull() || sending.get()) {
            return;
        }

        if (packet instanceof PlayerMoveC2SPacket || packet instanceof ClientStatusC2SPacket) {
            event.cancel();
            storedPackets.add(packet);
        }

        if (packet instanceof ChatMessageC2SPacket || packet instanceof ClientCommandC2SPacket) {
            sendPackets();
        }
    }

    @Override
    public void onHurt(HurtEvent event, LivingEntity entity) {
        if (entity instanceof PlayerEntity player && player == mc.player && !hurt.getValue()) {
            sendPackets();
        }
    }

    @Override
    public void onTick() {
        if (isNull()) {
            return;
        }

        if (auto.getValue()) {
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastAutoBlinkTime >= time.getValue() * 1000) {
                sendPackets();
                lastAutoBlinkTime = currentTime;
            }
        }

        if (storedPackets.size() >= maxPackets.getValue()) {
            sendPackets();
        }
    }

    @Override
    public void onDraw3D(MatrixStack matrixStack, float tickDelta) {
        if (isNull()) {
            return;
        }

        if (!mode.getValue().isEmpty() && lastPos != null) {
            if (mode.getValue().contains(Modes.Circle) && blinkCircle != null) {
                RenderSystem.disableDepthTest();
                RenderSystem.enableBlend();
                RenderSystem.blendFunc(GlStateManager.SrcFactor.SRC_ALPHA, GlStateManager.DstFactor.ONE);

                RenderSystem.setShaderTexture(0, TextureStorage.circle);

                RenderSystem.setShader(ShaderProgramKeys.POSITION_TEX_COLOR);
                BufferBuilder buffer = Tessellator.getInstance().begin(VertexFormat.DrawMode.QUADS, VertexFormats.POSITION_TEXTURE_COLOR);

                matrixStack.push();
                matrixStack.translate(blinkCircle.pos().x - mc.getEntityRenderDispatcher().camera.getPos().getX(), blinkCircle.pos().y - mc.getEntityRenderDispatcher().camera.getPos().getY(), blinkCircle.pos().z - mc.getEntityRenderDispatcher().camera.getPos().getZ());
                matrixStack.multiply(RotationAxis.POSITIVE_X.rotationDegrees(90));
                matrixStack.multiply(RotationAxis.POSITIVE_Z.rotationDegrees(1 * 1 * 1000f));
                Matrix4f matrix = matrixStack.peek().getPositionMatrix();

                buffer.vertex(matrix, -1, -1 + size.getValue().floatValue() * 2, 0).texture(0, 1).color(ColorUtil.applyOpacity(color.getValue(), 1).getRGB());
                buffer.vertex(matrix, -1 + size.getValue().floatValue() * 2, -1 + size.getValue().floatValue() * 2, 0).texture(1, 1).color(ColorUtil.applyOpacity(color.getValue(), 1).getRGB());
                buffer.vertex(matrix, -1 + size.getValue().floatValue() * 2, -1, 0).texture(1, 0).color(ColorUtil.applyOpacity(color.getValue(), 1).getRGB());
                buffer.vertex(matrix, -1, -1, 0).texture(0, 0).color(ColorUtil.applyOpacity(color.getValue(), 1).getRGB());

                matrixStack.pop();

                Render2DUtil.endBuilding(buffer);
                RenderSystem.disableBlend();
                RenderSystem.setShaderColor(1f, 1f, 1f, 1f);
                RenderSystem.enableDepthTest();
            }
            if (mode.getValue().contains(Modes.Model)) {
                if (blinkPlayer == null) {
                    blinkPlayer = new PlayerEntityCopy();
                    blinkPlayer.spawn();
                }
            }
        }
    }

    private void sendPackets() {
        if (isNull()) {
            return;
        }

        sending.set(true);

        while (!storedPackets.isEmpty()) {
            Packet<?> packet = storedPackets.poll();
            Vergence.NETWORK.sendPacket(packet);
            if (packet instanceof PlayerMoveC2SPacket && !(packet instanceof PlayerMoveC2SPacket.LookAndOnGround)) {
                lastPos = new Vec3d(((PlayerMoveC2SPacket) packet).getX(mc.player.getX()), ((PlayerMoveC2SPacket) packet).getY(mc.player.getY()), ((PlayerMoveC2SPacket) packet).getZ(mc.player.getZ()));
                blinkCircle = new Circle(new Vec3d(mc.player.getX(), (int) Math.floor(mc.player.getY()) + 0.001f, mc.player.getZ()), new FastTimerUtil());
                if (mode.getValue().contains(Modes.Model)) {
                    blinkPlayer.remove();
                    blinkPlayer = new PlayerEntityCopy();
                    blinkPlayer.spawn();
                }
            }
        }

        sending.set(false);
    }

    public record Circle(Vec3d pos, FastTimerUtil timer) {}

    public enum Modes {
        Circle,
        Model
    }
}