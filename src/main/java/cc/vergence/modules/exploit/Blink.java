package cc.vergence.modules.exploit;

import cc.vergence.Vergence;
import cc.vergence.features.event.events.PacketEvent;
import cc.vergence.features.options.Option;
import cc.vergence.features.options.impl.*;
import cc.vergence.modules.Module;
import cc.vergence.util.player.PlayerEntityCopy;
import cc.vergence.util.render.utils.Render2DUtil;
import cc.vergence.util.render.utils.Render3DUtil;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.util.InputUtil;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.play.*;
import net.minecraft.network.packet.s2c.play.EntityVelocityUpdateS2CPacket;
import net.minecraft.util.math.Vec3d;

import java.awt.*;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicBoolean;

public class Blink extends Module {
    public static Blink INSTANCE;
    private PlayerEntityCopy blinkPlayer;
    public static Vec3d lastPos = Vec3d.ZERO;
    private final Queue<Packet<?>> storedPackets = new LinkedList<>();
    private final AtomicBoolean sending = new AtomicBoolean(false);
    private long lastAutoBlinkTime = System.currentTimeMillis();

    public Blink() {
        super("Blink", Category.EXPLOIT);
        INSTANCE = this;
    }

    public Option<EnumSet<Modes>> mode = addOption(new MultipleOption<Modes>("Mode", EnumSet.of(Modes.Circle)));
    public Option<Boolean> auto = addOption(new BooleanOption("Auto", false));
    public Option<Double> time = addOption(new DoubleOption("Time", 0.1, 10, 2).setUnit("s"));
    public Option<Double> maxPackets = addOption(new DoubleOption("MaxPackets", 1, 2000, 20));
    public Option<Boolean> velocity = addOption(new BooleanOption("Velocity", false));
    public Option<Double> size = addOption(new DoubleOption("Size", 0.2, 2, 0.8, v -> mode.getValue().contains(Modes.Circle)));
    public Option<Color> color = addOption(new ColorOption("Color", new Color(251, 136, 255), v -> mode.getValue().contains(Modes.Circle)));

    @Override
    public String getDetails() {
        return String.valueOf(storedPackets.size());
    }

    @Override
    public void onEnable() {
        if (isNull() || mc.isIntegratedServerRunning() || mc.getNetworkHandler() == null) {
            disable();
            return;
        }

        lastPos = mc.player.getPos();
        mc.world.spawnEntity(new ClientPlayerEntity(mc, mc.world, mc.getNetworkHandler(), mc.player.getStatHandler(), mc.player.getRecipeBook(), mc.player.isSprinting(), mc.player.isSneaking()));
        sending.set(false);
        storedPackets.clear();
        lastAutoBlinkTime = System.currentTimeMillis();
    }

    @Override
    public void onDisable() {
        if (isNull()) {
            return;
        }

        sendPackets();

        if (blinkPlayer != null) {
            blinkPlayer.remove();
        }
        blinkPlayer = null;
    }

    @Override
    public void onSendPacket(PacketEvent.Send event, Packet<?> packet) {
        if (isNull() || sending.get()) {
            return;
        }

        if (packet instanceof PlayerMoveC2SPacket || packet instanceof ClientStatusC2SPacket) {
            event.cancel();
            storedPackets.add(packet);
        }

        if (packet instanceof ChatMessageC2SPacket || packet instanceof ClientCommandC2SPacket) {
            sendPackets();
        }
    }

    @Override
    public void onReceivePacket(PacketEvent.Receive event, Packet<?> packet) {
        if (isNull()) {
            return;
        }

        if (packet instanceof EntityVelocityUpdateS2CPacket vel && vel.getEntityId() == mc.player.getId() && !velocity.getValue()) {
            this.disable();
        }
    }

    @Override
    public void onTick() {
        if (isNull()) {
            return;
        }

        if (auto.getValue()) {
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastAutoBlinkTime >= time.getValue() * 1000) {
                sendPackets();
                lastAutoBlinkTime = currentTime;
            }
        }

        if (storedPackets.size() >= maxPackets.getValue()) {
            sendPackets();
        }
    }

    @Override
    public void onDraw3D(MatrixStack matrixStack, float tickDelta) {
        if (isNull()) {
            return;
        }

        if (!mode.getValue().isEmpty() && lastPos != null) {
            if (mode.getValue().contains(Modes.Circle)) {
                Render2DUtil.drawCircle(
                        matrixStack,
                        mc.player.getPos(),
                        size.getValue().floatValue(),
                        color.getValue(),
                        color.getValue().getAlpha() / 255f,
                        1
                );
            }
            if (mode.getValue().contains(Modes.Model)) {
                if (blinkPlayer == null) {
                    blinkPlayer = new PlayerEntityCopy();
                    blinkPlayer.spawn();
                }
            }
        }
    }

    private void sendPackets() {
        if (isNull()) {
            return;
        }

        sending.set(true);

        while (!storedPackets.isEmpty()) {
            Packet<?> packet = storedPackets.poll();
            Vergence.NETWORK.sendPacket(packet);
            if (packet instanceof PlayerMoveC2SPacket && !(packet instanceof PlayerMoveC2SPacket.LookAndOnGround)) {
                lastPos = new Vec3d(((PlayerMoveC2SPacket) packet).getX(mc.player.getX()), ((PlayerMoveC2SPacket) packet).getY(mc.player.getY()), ((PlayerMoveC2SPacket) packet).getZ(mc.player.getZ()));

                if (mode.getValue().contains(Modes.Model)) {
                    blinkPlayer.remove();
                    blinkPlayer = new PlayerEntityCopy();
                    blinkPlayer.spawn();
                }
            }
        }

        sending.set(false);
    }

    public enum Modes {
        Circle,
        Model
    }
}